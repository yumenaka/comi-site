<template>
  <div class="">
    <!-- 顶部,标题页头 -->
    <!-- 定位：https://www.tailwindcss.cn/docs/position -->
    <!-- 使用 fixed 来定位一个元素相对于浏览器窗视口的位置。偏移量是相对于视口计算的，且该元素将作为绝对定位的子元素的位置参考。 -->
    <!-- 控制 flex 和 grid 项目如何沿着容器的主轴定位:https://www.tailwindcss.cn/docs/justify-content -->
    <!-- 不透明度：opacity-70 https://www.tailwindcss.cn/docs/opacity -->
    <!-- Vue组建过渡：https://v3.cn.vuejs.org/guide/transitions-enterleave.html#%E5%8D%95%E5%85%83%E7%B4%A0-%E7%BB%84%E4%BB%B6%E7%9A%84%E8%BF%87%E6%B8%A1= -->
    <transition name="header-bottom">
      <Header v-if="FlipModeConfig.showHeaderFlag_FlipMode" in-shelf="false" :readMode="'flip'" class="w-full mx-auto opacity-80"
        v-bind:class="{ 'fixed': hideToolbar, absolute: hideToolbar, 'top-0': hideToolbar }"
        v-bind:style="{ background: model.interfaceColor }" :setDownLoadLink="needDownloadLink()"
        :headerTitle="book.title" :bookID="book.id" :depth="book.depth" :showReturnIcon="true" :showSettingsIcon="true"
        @drawerActivate="drawerActivate">
      </Header>
    </transition>

    <div class="main" v-bind:style="{ overflow: 'hidden' }">
      <!-- 主题,漫画div -->
      <!-- 事件修饰符： https://v3.cn.vuejs.org/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6 -->
      <div class="manga_area" id="MangaMain" @click.stop="onMouseClick" @mousemove.stop="onMouseMove"
        @mouseleave.stop="onMouseLeave">
        <div class="manga_area_img_div">
          <!-- 非自动拼合模式最简单,直接显示一张图 -->
          <img class="w-auto h-auto" v-bind:src="imageParametersString(book.pages.images[nowPageNum - 1].url)
        " v-bind:alt="nowPageNum.toString()" />

          <!-- 简单拼合双页,不管单双页什么的 -->
          <img v-if="!FlipModeConfig.autoDoublePageModeFlag &&
          FlipModeConfig.doublePageModeFlag &&
          nowPageNum < book.page_count
        " v-bind:src="imageParametersString(book.pages.images[nowPageNum].url)
        " v-bind:alt="(nowPageNum + 1).toString()" />

          <!-- 自动拼合模式当前页,如果开启自动拼合,右边可能显示拼合页 -->
          <img v-if="FlipModeConfig.autoDoublePageModeFlag &&
          nowPageNum < book.page_count &&
        nowAndNextPageIsSingle()
        " v-bind:src="imageParametersString(book.pages.images[nowPageNum].url)
        " v-bind:alt="(nowPageNum + 1).toString()" />
        </div>
      </div>
    </div>
    <!-- 页数、倒计时文字提示 -->
    <!-- Top / Right / Bottom / Left :用于控制定位元素的位置的功能类。https://www.tailwindcss.cn/docs/top-right-bottom-left -->
    <!-- 文字描边效果CSS参考了：https://www.zhangxinxu.com/wordpress/2017/06/webkit-text-stroke-css-text-shadow/ -->
    <div class="fixed bottom-0 w-full h-auto font-sans text-black "
      v-bind:class="{ 'text-2xl': FlipModeConfig.sketchModeFlag, 'text-lg': (!FlipModeConfig.sketchModeFlag) }"
      style="text-shadow: 0 1px yellow, 1px 0 yellow, -1px 0 yellow, 0 -1px yellow;" v-if="FlipModeConfig.showPageHintFlag_FlipMode">
      {{ pageNumOrSketchHint }}
    </div>

    <!-- 底部的阅读进度条 -->
    <transition name="header-bottom">
      <!-- 进度条 -->
      <!-- 宽度：w-5/6 https://www.tailwindcss.cn/docs/width 使用 w-{fraction} 或 w-full 将元素设置为基于百分比的宽度。 -->
      <!-- 定位：https://www.tailwindcss.cn/docs/position  -->
      <!-- 使用 fixed 来定位一个元素相对于浏览器窗视口的位置。偏移量是相对于视口计算的，且该元素将作为绝对定位的子元素的位置参考。 -->
      <!-- 控制 flex 和 grid 项目如何沿着容器的主轴定位:https://www.tailwindcss.cn/docs/justify-content -->
      <!-- Tailwind 的容器不会自动居中，也没有任何内置的水平方向的内边距。要使一个容器居中，使用 mx-auto 功能类： -->
      <!-- absolute bottom-0  -->
      <!-- v-bind:class="{ absolute: hideToolbar, 'bottom-0': hideToolbar, 'fixed': hideToolbar, 'flex': !hideToolbar}" -->

      <div class="w-full h-10 m-0 overflow-hidden opacity-80"
        v-bind:class="{ absolute: hideToolbar, 'bottom-0': hideToolbar, 'flex': (!hideToolbar) }"
        v-if="FlipModeConfig.showFooterFlag_FlipMode">
        <div class="flex flex-row items-end justify-center w-full h-10 mx-auto bg-yellow-400 ">
          <!-- 底部滑动条,日漫模式，reverse翻转计数方向 -->
          <!-- 背景颜色：bg-blue-300  https://www.tailwindcss.cn/docs/background-color  -->
          <div class="flex flex-row items-center justify-center w-5/6 h-full px-4 bg-blue-300 " v-if="!FlipModeConfig.rightToLeftFlag">
            <span class="right">{{ book.page_count }}</span>
            <n-slider class="w-10/11" reverse v-model:value="nowPageNum" :max="book.page_count" :min="1" :step="1"
              :format-tooltip="(value: any) => `${value}`" @update:value="saveLocalBookMark" />
            <span class="left">{{ nowPageNum }}</span>
          </div>

          <!-- 底部滑动条，美漫模式 -->
          <!-- h-full: 将一个元素的高度设置为其父元素的 100%，只要父元素有一个定义的高度。 https://www.tailwindcss.cn/docs/height -->
          <!-- 使用 items-center 沿着容器的交叉轴中心对齐项目：https://www.tailwindcss.cn/docs/align-items#center=  -->
          <div class="flex flex-row items-center justify-center w-5/6 h-full px-4 bg-blue-300 " v-if="FlipModeConfig.rightToLeftFlag">
            <span class="right">{{ nowPageNum }}</span>
            <n-slider class="bg-yellow-300" v-model:value="nowPageNum" :max="book.page_count" :min="1" :step="1"
              :format-tooltip="(value: any) => `${value}`" @update:value="saveLocalBookMark" />
            <span class="left">{{ book.page_count }}</span>
          </div>
        </div>
      </div>
    </transition>

    <!-- 设置抽屉,一开始隐藏 -->
    <Drawer :initDrawerActive="drawerActive" :initDrawerPlacement="drawerPlacement" @saveConfig="saveConfigToLocal"
      @startSketch="startSketchMode" @stopSketch="stopSketchMode" @closeDrawer="drawerDeactivate"
      :readerMode="FlipModeConfig.readerMode" :inBookShelf="false" :sketching="FlipModeConfig.sketchModeFlag">

      <!-- 选择：切换页面模式 -->
      <n-button @click="changeReaderModeToScrollMode">{{
        $t("switch_to_scrolling_mode")
      }}
      </n-button>

      <!-- 页面重新排序 -->
      <n-select :placeholder='$t("re_sort_page")' @update:value="onResort" :options="options" />
      <!-- 空白行-->
      <!-- <p> &nbsp;</p> -->

      <!-- websocket同步 -->
      <n-switch size="large" v-model:value="FlipModeConfig.syncPageByWS" @update:value="setSyncPageByWS">
        <template #checked>{{ $t("sync_page") }}</template>
        <template #unchecked>{{ $t("sync_page") }}</template>
      </n-switch>

      <!-- 显示当前页数 -->
      <n-switch size="large" v-model:value="FlipModeConfig.showPageHintFlag_FlipMode" @update:value="setShowPageNumChange">
        <template #checked>{{ $t("showPageNum") }}</template>
        <template #unchecked>{{ $t("showPageNum") }}</template>
      </n-switch>

      <!-- 保存阅读的页数 -->
      <n-switch size="large" v-model:value="FlipModeConfig.saveNowPageNumFlag" @update:value="setSavePageNumFlag">
        <template #checked>{{ $t("savePageNum") }}</template>
        <template #unchecked>{{ $t("savePageNum") }}</template>
      </n-switch>

      <!-- 合并双页 -->
      <n-switch size="large" v-model:value="FlipModeConfig.doublePageModeFlag" :rail-style="railStyle"
        @update:value="setSimpleDoublePage_FlipMode">
        <template #checked>{{ $t("DoublePageMode") }}</template>
        <template #unchecked>{{ $t("SinglePageMode") }}</template>
      </n-switch>

      <!-- 更改跨页匹配 -->
      <n-button @click="FlipOddEvenPage" v-if="FlipModeConfig.doublePageModeFlag" :title="$t('FlipOddEvenPageHint')">{{
        $t("Flip_odd_even_page")
      }}
      </n-button>


      <!-- 自动切边 -->
      <n-switch size="large" v-model:value="imageParameters.do_auto_crop" @update:value="setImageParameters_DoAutoCrop">
        <template #checked>{{ $t("auto_crop") }}</template>
        <template #unchecked>{{ $t("auto_crop") }}</template>
      </n-switch>
      <!-- TODO:@update:value="setImageParameters_AutoCropNum"  语法错误？  切白边阈值 -->
      <n-input-number :show-button="false" v-if="imageParameters.do_auto_crop"
        v-model:value="imageParameters.auto_crop_num" :max="10" :min="0">
        <template #prefix>{{ $t("energy_threshold") }}</template>
      </n-input-number>

      <!-- 翻页模式,默认右开本（日漫）-->
      <n-switch size="large" v-model:value="FlipModeConfig.rightToLeftFlag" :rail-style="railStyle" @update:value="setFlipScreenFlag">
        <template #checked>{{ $t("leftScreenToNext") }}</template>
        <template #unchecked>{{ $t("rightScreenToNext") }}</template>
      </n-switch>

      <!-- 自动隐藏工具栏 -->
      <n-switch size="large" v-model:value="hideToolbar" @update:value="setHideToolbar">
        <template #checked>{{ $t('auto_hide_toolbar') }}</template>
        <template #unchecked>{{ $t('auto_hide_toolbar') }}</template>
      </n-switch>

      <!-- 分割线 -->
      <n-divider v-if="FlipModeConfig.readerMode === 'sketch'" />
      <!-- 自动翻页秒数 -->
      <!-- 数字输入% -->
      <n-input-number v-if="FlipModeConfig.readerMode === 'sketch'" size="small" :show-button="false" v-model:value="sketchFlipSecond"
        :max="65535" :min="1" :update-value-on-input="false" @update:value="resetSketchSecondCount">
        <template #prefix>{{ $t("pageTurningSeconds") }}</template>
        <template #suffix>{{ $t("second") }}</template>
      </n-input-number>
      <!-- 滑动选择% -->
      <n-slider v-if="FlipModeConfig.readerMode === 'sketch'" v-model:value="sketchFlipSecond" :step="1" :max="120" :min="1"
        :marks="marks" :format-tooltip="(value: any) => `${value}s`" @update:value="resetSketchSecondCount" />

      <!-- Debug,开启一些不稳定功能 -->
      <!-- <n-switch size="large" v-model:value="debugModeFlag" @update:value="setDebugModeFlag">
        <template #checked>{{ $t("debugMode") }}</template>
        <template #unchecked>{{ $t("debugMode") }}</template>
      </n-switch>

      <n-switch v-if="debugModeFlag" size="large" v-model:value="autoDoublePageModeFlag"
        @update:value="setAutoDoublePage_FlipMode">
        <template #checked>{{ $t('autoDoublePage') }}</template>
        <template #unchecked>{{ $t('autoDoublePage') }}</template>
      </n-switch>  -->
    </Drawer>
  </div>
</template>

<script lang="ts">
import { useCookies } from "vue3-cookies";
// 自定义组件
import Header from "@/components/Header.vue";
import Drawer from "@/components/Drawer.vue";
// import Bottom from "@/components/Bottom.vue";
import { defineComponent, reactive, getCurrentInstance, CSSProperties } from "vue";
import { useStore } from '@/store'
import { useRoute, useRouter } from 'vue-router'
// 直接导入组件并使用它。这种情况下,只有导入的组件才会被打包。
import {
  NDivider,
  NInputNumber,
  NSlider,
  NSwitch,
  useMessage,
  NButton,
  NSelect,
} from "naive-ui";
import axios from "axios";

export default defineComponent({
  name: "FlipMode",
  props: ["someProp"],
  emits: ["childMark"], // 向父组件传递参数的函数,用法： 子组件调用：this.$emit("childMark", value); 父组件：@childMark="this.fatherMethod"
  components: {
    Header,
    Drawer,
    // NSpace, //间距 https://www.naiveui.com/zh-CN/os-theme/components/space
    NSlider, //滑动选择  Slider https://www.naiveui.com/zh-CN/os-theme/components/slider
    NSwitch, //开关   https://www.naiveui.com/zh-CN/os-theme/components/switch
    NDivider, //分割线  https://www.naiveui.com/zh-CN/os-theme/components/divider
    NInputNumber, ///  https://www.naiveui.com/zh-CN/os-theme/components/input-number
    NButton, //按钮，来自:https://www.naiveui.com/zh-CN/os-theme/components/button
    // NDropdown, //下拉菜单 https://www.naiveui.com/zh-CN/os-theme/components/dropdown
    NSelect, //选择器 https://www.naiveui.com/zh-CN/os-theme/components/select
  },
  setup() {
    const { cookies } = useCookies();
    const app = getCurrentInstance();
    const store = useStore()
    const router = useRouter()
    //背景颜色,颜色选择器用
    const model = reactive({
      backgroundColor: "#E0D9CD",
      interfaceColor: "#f5f5e4",
    });
    //请求图片文件时，可添加的额外参数
    const imageParameters = reactive({
      resize_width: -1, // 缩放图片,指定宽度
      resize_height: -1, // 指定高度,缩放图片
      do_auto_resize: false,
      resize_max_width: 800, //图片宽度大于这个上限时缩小
      resize_max_height: -1, //图片高度大于这个上限时缩小
      do_auto_crop: false,
      auto_crop_num: 1, // 自动切白边阈值,范围是0~100,其实为1就够了
      gray: false, //黑白化
    });

    //警告信息
    const message = useMessage();
    return {
      message,
      //背景色
      model,
      cookies,
      imageParameters, //获取图片所用的参数
      imageParametersString: (source_url: string) => {
        // var temp =
        if (source_url.substr(0, 12) === "api/get_file?") {
          //当前URL
          const url = document.location.toString();
          //按照“/”分割字符串
          const arrUrl = url.split("/");
          //拼一个完整的图片URL（因为路由路径会变化,所以不能用相对路径？）
          const base_str = arrUrl[0] + "//" + arrUrl[2] + "/" + source_url;
          //添加各种字符串参数,不需要的话为空
          const resize_width_str =
            imageParameters.resize_width > 0
              ? "&resize_width=" + imageParameters.resize_width
              : "";
          const resize_height_str =
            imageParameters.resize_height > 0
              ? "&resize_height=" + imageParameters.resize_height
              : "";
          const gray_str = imageParameters.gray ? "&gray=true" : "";
          const do_auto_resize_str = imageParameters.do_auto_resize
            ? "&resize_max_width=" + imageParameters.resize_max_width
            : "";
          const resize_max_height_str =
            imageParameters.resize_max_height > 0
              ? "&resize_max_height=" + imageParameters.resize_max_height
              : "";
          const auto_crop_str = imageParameters.do_auto_crop
            ? "&auto_crop=" + imageParameters.auto_crop_num
            : "";
          //所有附加的转换参数
          const addStr =
            resize_width_str +
            resize_height_str +
            do_auto_resize_str +
            resize_max_height_str +
            auto_crop_str +
            gray_str;
          //如果有附加转换参数，则设置成不缓存
          const nocache_str = addStr === "" ? "" : "&no-cache=true";
          return base_str + addStr + nocache_str;
        } else {
          return source_url;
        }
      },
      //开关颜色
      railStyle: ({
        focused,
        checked
      }: {
        focused: boolean
        checked: boolean
      }) => {
        const style: CSSProperties = {}
        if (checked) {
          style.background = '#d03050'
          if (focused) {
            style.boxShadow = '0 0 0 2px #d0305040'
          }
        } else {
          style.background = '#2080f0'
          if (focused) {
            style.boxShadow = '0 0 0 2px #2080f040'
          }
        }
        return style
      },
      //滑动秒数建议值
      marks: {
        30: "30",
        60: "60",
        90: "90",
        120: "120",
      },
    };
  },
  data() {
    return {
      //自动隐藏工具条
      interval: 0,
      hideToolbar: true,
      resort_hint_key: "resort",
      options: [
        {
          label: this.$t("sort_by_filename"),
          value: "filename",
        },
        {
          label: this.$t("sort_by_modify_time"),
          value: "modify_time",
        },
        {
          label: this.$t("sort_by_filesize"),
          value: "filesize",
        },
        {
          label: this.$t("sort_by_filename") + this.$t("sort_reverse"),
          value: "filename_reverse",
        },
        {
          label: this.$t("sort_by_modify_time") + this.$t("sort_reverse"),
          value: "modify_time_reverse",
        },
        {
          label: this.$t("sort_by_filesize") + this.$t("sort_reverse"),
          value: "filesize_reverse",
        },
      ],
      book: {
        title: "loading",
        id: "loading",
        page_count: 2,
        type: ".zip",
        depth: 0,
        pages: {
          sort_by: "",
          images: [
            {
              height: 500,
              width: 449,
              url: "/images/loading.gif",
            },
            {
              height: 500,
              width: 449,
              url: "/images/loading.gif",
            },
          ],
        },
      },
      drawerActive: false,
      drawerPlacement: "right",
      //当前页数,注意语义,直接就是1开始的页数,不是数组下标,在pages数组当中用的时候需要-1
      nowPageNum: 1,
      //最后发送的页数，用来避免重复发送用
      lastSendNowPageNum: 1,
      FlipModeConfig: {
        readerMode: "flip",
        //开发模式 未完成的功能与设置,开启Debug以后才能见到
        debugModeFlag: true,
        //是否通过websocket同步翻页
        syncPageByWS: true,
        //是否显示页头
        showHeaderFlag_FlipMode: true,
        //是否显示页脚
        showFooterFlag_FlipMode: true,
        //是否是右半屏翻页（从右到左）?日本漫画从左到右(false)
        rightToLeftFlag: false,
        //简单拼合双叶
        doublePageModeFlag: false,
        //自动拼合双叶,效果不太好
        autoDoublePageModeFlag: false,
        //是否保存当前页数
        saveNowPageNumFlag: true,

        //素描模式标记
        sketchModeFlag: false,
        //是否显示素描提示
        showPageHintFlag_FlipMode: false,
        interfaceColor: "#F5F5E4",
        backgroundColor: "#E0D9CD",
      },
      //翻页间隔时间
      sketchFlipSecond: 30,
      //计时用,从0开始
      sketchSecondCount: 0,
    };
  },
  //在选项API中使用 Vue 生命周期钩子：
  created() {
    //初始化阅读器设置
    let configString = localStorage.getItem('FlipModeConfig');
		if (localStorage.getItem('FlipModeConfig') !== null && typeof configString === "string") {
				this.FlipModeConfig = JSON.parse(configString)
				this.model.backgroundColor = this.FlipModeConfig.backgroundColor;
				this.model.interfaceColor = this.FlipModeConfig.interfaceColor;
		}
    //UI配色
		const tempBackgroundColor = localStorage.getItem("BackgroundColor")
		if (typeof (tempBackgroundColor) === 'string') {
			this.FlipModeConfig.backgroundColor = tempBackgroundColor;
		}
		const tempInterfaceColor = localStorage.getItem("InterfaceColor")
		if (typeof (tempInterfaceColor) === 'string') {
			this.FlipModeConfig.interfaceColor = tempInterfaceColor
		}
		this.model.backgroundColor = this.FlipModeConfig.backgroundColor;
		this.model.interfaceColor = this.FlipModeConfig.interfaceColor;

    // 消息监听，即接收websocket服务端推送的消息. optionsAPI用法
    this.$options.sockets.onmessage = (data: any) => this.handlePacket(data);
    //根据文件名、修改时间、文件大小等要素排序的参数
    let sort_image_by_str = "";
    if (this.$route.query.sort_by) {
      sort_image_by_str = "&sort_by=" + this.$route.query.sort_by;
    }

    //根据路由参数获取特定书籍
    axios
      .get("/get_book?id=" + this.$route.params.id + sort_image_by_str)
      .then((response) => (this.book = response.data))
      .catch((error) => {
        console.log("请求接口失败" + error);
      })
      .finally(() => {
        document.title = this.book.title;
        console.log("成功获取书籍数据,书籍ID:" + this.$route.params.id);
        this.loadLocalBookMark();
      });
    //监听路由参数的变化,刷新本地的Book数据
    this.$watch(
      () => this.$route.params.id,
      (id: any) => {
        // console.log(id)
        axios
          .get("/get_book?id=" + this.$route.params.id + sort_image_by_str)
          .then((response) => (this.book = response.data))
          .catch((error) => {
            console.log("请求接口失败" + error);
          })
          .finally(() => console.log("路由参数改变,书籍ID:" + id));
      }
    );
  },
  // beforeMount : 指令第一次绑定到元素并且在挂载父组件之前调用。
  beforeMount() {
    // 自动开始Sketch模式
    if (localStorage.getItem("ReaderMode") === "sketch") {
      this.startSketchMode();
    }
    // 注册监听
    window.addEventListener("keyup", this.handleKeyup);
  },
  //卸载前
  beforeUnmount() {
    // 销毁监听
    window.removeEventListener("keyup", this.handleKeyup);
    //移除websocket消息监听
    delete this.$options.sockets.onmessage;
  },
  // mounted : 在绑定元素的父组件被挂载后调用。
  mounted() {
    //延迟1秒执行
    // setTimeout(this.doSomeThing, 1000);
  },
  updated() {
    //界面有更新就会调用,随便乱放会引起难以调试的BUG
  },
  methods: {
    //接收服务器发来的websocket消息，做各种反应（翻页、提示信息）
    handlePacket(data: { data: string; }) {
      if (this.FlipModeConfig.syncPageByWS === false) {
        return;
      }
      //data.data也是个字符串，需要解析成对象
      const msg = JSON.parse(data.data);
      //心跳信息,直接返回
      if (msg.type === "heartbeat") {
        return;
      }
      //确保服务器发来翻页信息，来自于另一个用户
      if (msg.user_id == this.$store.userID) {
        console.log(this.$store.userID + "接收到Message:msg.user_id=" + msg.user_id);
        return;
      }
      // console.log("FlipMode 接收到Message:",msg);
      //服务器发来翻页信息，来自于另一个用户才做反应
      if (msg.type === "flip_mode_sync_page") {
        const syncData = JSON.parse(msg.data_string);
        //正在读的是同一本书、就翻页。
        if (syncData.book_id === this.book.id && syncData.now_page_num !== this.nowPageNum) {
          // console.log(syncData);
          //如果是合并双页的状态，那么页数差距必须大于1才翻页
          if (this.FlipModeConfig.doublePageModeFlag && (syncData.now_page_num - this.nowPageNum === 1 || syncData.now_page_num - this.nowPageNum === -1)) {
            return
          }
          this.toPage(syncData.now_page_num, false);
        }
      }
    },

    //Websocket 发送消息
    sendNowPage() {
      //同一个页数只发送一回
      if (this.lastSendNowPageNum === this.nowPageNum) {
        return
      }
      this.lastSendNowPageNum = this.nowPageNum;
      const data = {
        book_id: this.book.id,
        now_page_num: this.nowPageNum,
        need_double_page_mode: this.FlipModeConfig.doublePageModeFlag,
      };
      // console.log("this.$store.userID: " + this.$store.state.userID)
      const newMsg = {
        type: "flip_mode_sync_page",
        status_code: 200,
        user_id: this.$store.state.userID,
        token: this.$store.state.token,
        detail: "翻页模式，发送数据", // 消息描述
        data_string: JSON.stringify(data),
      };
      // 配置为了json，可调用sendObj方法来发送数据
      // console.dir(this.$socket)
      this.$socket.sendObj(newMsg);
      console.log("send:", newMsg);
    },

    //页面排序相关
    onResort(key: string) {
      this.resort_hint_key = key;
      axios
        .get("/get_book?id=" + this.$route.params.id + "&sort_by=" + key)
        .then((response) => (this.book = response.data))
        .finally(() => {
          document.title = this.book.title;
          this.resort_hint_key = key;
          // 带查询参数，结果是 /#/flip/abc123?sort_by="filesize"
          this.$router.push({
            name: "FlipMode",
            replace: true,
            query: { sort_by: key },
          });
          console.log(
            "成功刷新书籍数据,书籍ID:" +
            this.$route.params.id +
            "  sort_by=" +
            key
          );
        });
    },
    //图片处理相关
    //黑白化参数
    setImageParameters_Gray(value: boolean) {
      // console.log("value:" + value);
      this.imageParameters.gray = value;
      localStorage.setItem("ImageParameters_Gray", value ? "true" : "false");
      // console.log("成功保存设置: ImageParameters_Gray=" + localStorage.getItem("ImageParameters_Gray"));
    },
    //缩放图片大小的参数
    setImageParameters_DoAutoResize(value: boolean) {
      this.imageParameters.do_auto_resize = value;
      localStorage.setItem("ImageParameters_DoAutoResize", value ? "true" : "false");
      // console.log("成功保存设置: ImageParameters_DoAutoResize=" + localStorage.getItem("ImageParameters_DoAutoResize"));
    },
    //设置是否切白边
    setImageParameters_DoAutoCrop(value: boolean) {
      this.imageParameters.do_auto_crop = value;
      localStorage.setItem(
        "ImageParameters_DoAutoCrop",
        this.imageParameters.do_auto_crop ? "true" : "false"
      );
      // console.log("成功保存设置: ImageParameters_DoAutoCrop=" + localStorage.getItem("ImageParameters_DoAutoCrop"));
    },
    //切白边参数
    setImageParameters_AutoCropNum(value: number) {
      this.imageParameters.auto_crop_num = value;
      localStorage.setItem(
        "ImageParameters_AutoCropNum",
        this.imageParameters.auto_crop_num.toString()
      );
    },
    //切换到卷轴模式
    changeReaderModeToScrollMode() {
      localStorage.setItem("ReaderMode", "scroll");
      //replace的作用类似于 router.push，唯一不同的是，它在导航时不会向 history 添加新记录，正如它的名字所暗示的那样——它取代了当前的条目。
      this.$router.replace({
        name: "ScrollMode",
        replace: true,
        params: { id: this.$route.params.id },
      });
    },
    FlipOddEvenPage() {
      if (this.nowPageNum % 2 == 0)
        this.flipPage(-1)
      else
        this.flipPage(1);
    },
    //判断这本书是否需要提供原始压缩包下载
    needDownloadLink() {
      return this.book.type !== "dir";
    },
    // 分析单双页用
    nowAndNextPageIsSingle() {
      let nowPageIsDouble = this.checkImageIsDoublePage_byPageNum(
        this.nowPageNum
      );
      let nextPageIsDouble = this.checkImageIsDoublePage_byPageNum(
        this.nowPageNum + 1
      );
      return !(nowPageIsDouble || nextPageIsDouble);
    },
    //根据书籍UUID,设定当前页数,因为需要取得远程书籍数据（this.book）,所以延迟执行
    loadLocalBookMark() {
      if (!this.FlipModeConfig.saveNowPageNumFlag) {
        return
      }
      let cookieValue = localStorage.getItem("nowPageNum" + this.book.id);
      if (cookieValue === null) {
        console.log("本队存储里没找到:" + "nowPageNum = " + this.nowPageNum);
        return
      }
      let saveNum = Number(cookieValue);
      if (isNaN(saveNum)) {
        console.log("读取页数失败,this.nowPageNum = " + this.nowPageNum);
        return
      }
      this.nowPageNum = saveNum;
      console.log("成功读取页数" + saveNum);
    },
    // // 设置当前模板-接收Drawer的参数,继续往父组件传
    // 改变阅读模式
    OnSetTemplate(value: string) {
      if (value === "scroll") {
        console.log("跳转到卷轴阅读模式");
      } else if (this.FlipModeConfig.readerMode === "scroll" || this.FlipModeConfig.readerMode === "sketch") {
        // 命名路由,并加上参数,让路由建立 url
        this.$router.push({ name: "ScrollMode", params: { id: this.book.id } });
      }
    },
    //打开抽屉
    drawerActivate(place: string) {
      this.drawerActive = true;
      this.drawerPlacement = place;
      //打开抽屉时，触发工具条显隐
      if (this.hideToolbar) {
        this.FlipModeConfig.showHeaderFlag_FlipMode = true
        this.FlipModeConfig.showFooterFlag_FlipMode = true
      }
    },
    //关闭抽屉
    drawerDeactivate() {
      this.drawerActive = false;
      //关闭抽屉时，触发工具条显隐
      if (this.hideToolbar) {
        this.FlipModeConfig.showHeaderFlag_FlipMode = false
        this.FlipModeConfig.showFooterFlag_FlipMode = false
      }
    },
    //开始速写倒计时
    startSketchMode() {
      this.FlipModeConfig.readerMode = "sketch";
      localStorage.setItem("ReaderMode", "sketch");
      this.message.success(this.$t("startSketchMessage"));
      this.drawerActive = false; //关闭设置抽屉
      this.FlipModeConfig.sketchModeFlag = true;
      //是否倒计时提示文字
      this.FlipModeConfig.showPageHintFlag_FlipMode = true;
      //是否显示页头
      this.FlipModeConfig.showHeaderFlag_FlipMode = false;
      //是否显示页脚
      this.FlipModeConfig.showFooterFlag_FlipMode = false;
      //setTimeout和setInterval函数,都返回一个表示计数器编号的整数值,将该整数传入clearTimeout和clearInterval函数,就可以取消对应的定时器。setInterval指定某个任务每隔一段时间就执行一次。setTimeout()用于在指定的毫秒数后调用函数或计算表达式  setTimeout('console.log(2)',1000);
      this.interval = setInterval(this.sketchCount, 1000);
    },
    //修改间隔的时候重新计秒数
    resetSketchSecondCount() {
      this.sketchSecondCount = 0;
    },
    //停止速写倒计时
    stopSketchMode() {
      this.message.success(this.$t("goodjob_and_byebye"));
      this.FlipModeConfig.sketchModeFlag = false;
      this.FlipModeConfig.showPageHintFlag_FlipMode = false;
      this.sketchSecondCount = 0;
      //是否显示页头
      this.FlipModeConfig.showHeaderFlag_FlipMode = true;
      //是否显示页脚
      this.FlipModeConfig.showFooterFlag_FlipMode = true;
      this.FlipModeConfig.readerMode = "flip";
      localStorage.setItem("ReaderMode", "flip");
      clearInterval(this.interval); // 清除定时器
    },
    //开始速写（quick sketch）,每秒执行一次
    sketchCount() {
      if (!this.FlipModeConfig.sketchModeFlag || this.FlipModeConfig.readerMode === "flip") {
        this.stopSketchMode();
        return
      }
      this.sketchSecondCount = this.sketchSecondCount + 1;
      let nowSecond = this.sketchSecondCount % this.sketchFlipSecond;
      // console.log("sketchSecondCount=" + this.sketchSecondCount + " nowSecond:" + nowSecond)
      if (nowSecond === 0) {
        if (this.nowPageNum < this.book.page_count) {
          this.flipPage(1);
        } else {
          this.toPage(1);
        }
      }
    },
    // 关闭抽屉时,保存设置到cookies
    saveConfigToLocal() {
      localStorage.setItem("FlipModeConfig", JSON.stringify(this.FlipModeConfig));
      console.log("成功保存设置: FlipModeConfig=" + localStorage.getItem("FlipModeConfig"));
    },
    //HTML DOM 事件 https://www.runoob.com/jsref/dom-obj-event.html
    // 进入绑定该事件的元素和其子元素均会触发该事件,所以有一个重复触发,冒泡过程。其对应的离开事件 mouseout
    onMouseOver() {
    },
    // 只有进入绑定该事件的元素才会触发事件,也就是不会冒泡。其对应的离开事件mouseleave
    onMouseEnter() {

    },
    onMouseLeave(e: any) {
      //离开区域的时候,清空鼠标样式
      e.currentTarget.style.cursor = "";
    },
    //事件修饰符: https://v3.cn.vuejs.org/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6
    onMouseMove(e: any) {
      // // offsetX/Y获取到是触发点相对被触发dom的左上角距离
      // let offsetX = e.offsetX;
      // let offsetY = e.offsetY;
      //根据ID获取元素
      // let mangaDiv =document.getElementById("MangaMain")
      //不用自己获取元素
      // let offsetWidth = e.currentTarget.offsetWidth;
      // let offsetHeight = e.currentTarget.offsetHeight;
      let clickX = e.x; //获取鼠标的X坐标（鼠标与屏幕左侧的距离,单位为px）
      let clickY = e.y; //获取鼠标的Y坐标（鼠标与屏幕顶部的距离,单位为px）
      // console.log("clickX: " + clickX);
      // console.log("clickY: " + clickY);
      // 浏览器的视口,不包括工具栏和滚动条:
      let innerWidth = window.innerWidth;
      let innerHeight = window.innerHeight;

      //是否进入上下工具条附近区域时，触发工具条显隐
      const toolBarArea = 0.10;
      let inToolBarArea = false
      if (clickY <= (innerHeight * toolBarArea) || clickY >= (innerHeight * (1.0 - toolBarArea))) {
        inToolBarArea = true
      }
      //进入设置区域的时候，设置鼠标的形状
      //设置区域为正方形，边长按照宽或高里面，比较小的值决定
      const setArea = 0.15;
      // innerWidth >= innerHeight 的情况下
      let MinY = innerHeight * (0.5 - setArea);
      let MaxY = innerHeight * (0.5 + setArea);
      let MinX = innerWidth * 0.5 - (MaxY - MinY) * 0.5;
      let MaxX = innerWidth * 0.5 + (MaxY - MinY) * 0.5;
      if (innerWidth < innerHeight) {
        MinX = innerWidth * (0.5 - setArea);
        MaxX = innerWidth * (0.5 + setArea);
        MinY = innerHeight * 0.5 - (MaxX - MinX) * 0.5;
        MaxY = innerHeight * 0.5 + (MaxX - MinX) * 0.5;
      }
      //在设置区域
      let inSetArea = false
      if (clickX > MinX && clickX < MaxX && clickY > MinY && clickY < MaxY) {
        inSetArea = true
      }
      if (inSetArea) {
        e.currentTarget.style.cursor =
          "url(/images/SettingsOutline.png), pointer";
      } else {
        if (clickX < innerWidth * 0.5) {
          //设置左边的鼠标指针
          if (this.FlipModeConfig.rightToLeftFlag && this.nowPageNum === 1) {
            //右边翻下一页,且目前是第一页的时候,左边的鼠标指针,设置为禁止翻页
            e.currentTarget.style.cursor =
              "url(/images/Prohibited28Filled.png), pointer";
          } else if (
            !this.FlipModeConfig.rightToLeftFlag &&
            this.nowPageNum === this.book.page_count
          ) {
            //左边翻下一页,且目前是最后一页的时候,左边的鼠标指针,设置为禁止翻页
            e.currentTarget.style.cursor =
              "url(/images/Prohibited28Filled.png), pointer";
          } else {
            //正常情况下,左边是向左的箭头
            e.currentTarget.style.cursor =
              "url(/images/ArrowLeft.png), pointer";
          }
        } else {
          //设置右边的鼠标指针
          if (
            this.FlipModeConfig.rightToLeftFlag &&
            this.nowPageNum === this.book.page_count
          ) {
            //右边翻下一页,且目前是最后页的时候,右边的鼠标指针,设置为禁止翻页
            e.currentTarget.style.cursor =
              "url(/images/Prohibited28Filled.png), pointer";
          } else if (!this.FlipModeConfig.rightToLeftFlag && this.nowPageNum === 1) {
            //左边翻下一页,且目前是第一页的时候,右边的鼠标指针,设置为禁止翻页
            e.currentTarget.style.cursor =
              "url(/images/Prohibited28Filled.png), pointer";
          } else {
            //正常情况下,右边是向右的箭头
            e.currentTarget.style.cursor =
              "url(/images/ArrowRight.png), pointer";
          }
        }
      }
      //进入上下工具条附近区域时，触发工具条显隐
      if ((inToolBarArea || inSetArea) && this.hideToolbar) {
        this.FlipModeConfig.showHeaderFlag_FlipMode = true
        this.FlipModeConfig.showFooterFlag_FlipMode = true
      } else if (this.hideToolbar) {
        this.FlipModeConfig.showHeaderFlag_FlipMode = false
        this.FlipModeConfig.showFooterFlag_FlipMode = false
      }
    },

    //根据鼠标点击事件的位置,决定是左右翻页还是打开设置
    onMouseClick(e: any) {
      let clickX = e.x; //获取鼠标的X坐标（鼠标与屏幕左侧的距离,单位为px）
      let clickY = e.y; //获取鼠标的Y坐标（鼠标与屏幕顶部的距离,单位为px）
      //浏览器的可视区域宽高,不包括工具栏和滚动条:
      let innerHeight = window.innerHeight;
      let innerWidth = window.innerWidth;
      // 设置区域为正方形
      const setArea = 0.15;
      // innerWidth >= innerHeight 的情况下
      let MinY = innerHeight * (0.5 - setArea);
      let MaxY = innerHeight * (0.5 + setArea);
      let MinX = innerWidth * 0.5 - (MaxY - MinY) * 0.5;
      let MaxX = innerWidth * 0.5 + (MaxY - MinY) * 0.5;
      if (innerWidth < innerHeight) {
        MinX = innerWidth * (0.5 - setArea);
        MaxX = innerWidth * (0.5 + setArea);
        MinY = innerHeight * 0.5 - (MaxX - MinX) * 0.5;
        MaxY = innerHeight * 0.5 + (MaxX - MinX) * 0.5;
      }
      // console.log("鼠标点击：e.offsetX=" + offsetX, "e.offsetY=" + offsetY);
      if (clickX > MinX && clickX < MaxX && clickY > MinY && clickY < MaxY) {
        //点中了设置区域
        this.drawerActivate("right");
      } else {
        //决定如何翻页
        if (clickX < innerWidth * 0.5) {
          //左边的翻页
          if (this.FlipModeConfig.rightToLeftFlag) {
            this.toPerviousPage();
          } else {
            this.toNextPage();
          }
        } else {
          //右边的翻页
          if (this.FlipModeConfig.rightToLeftFlag) {
            this.toNextPage();
          } else {
            this.toPerviousPage();
          }
        }
      }
    },
    toNextPage() {
      //简单合并模式
      if (this.FlipModeConfig.doublePageModeFlag) {
        if (this.nowPageNum < this.book.page_count - 1) {
          this.flipPage(2);
          return;
        } else {
          this.flipPage(1);
          return;
        }
      }

      //如果开启了自动合并模式,并且当前页应该被合并
      if (
        this.FlipModeConfig.autoDoublePageModeFlag &&
        this.checkMergedStatus_ByPageNum(this.nowPageNum)
      ) {
        if (this.nowPageNum < this.book.page_count - 1) {
          this.flipPage(2);
        } else {
          this.flipPage(1);
        }
      } else {
        this.flipPage(1);
      }
    },
    toPerviousPage() {
      //错误值,第0或第1页。
      if (this.nowPageNum <= 1) {
        // console.log("Error toPerviousPage");
        this.message.info(this.$t("hintFirstPage"));
        return;
      }

      //简单合并模式
      if (this.FlipModeConfig.doublePageModeFlag) {
        if (this.nowPageNum - 2 > 0) {
          this.flipPage(-2);
          return;
        } else {
          this.flipPage(-1);
          return;
        }
      }

      //自动合并模式
      //如果没有开启自动合并模式,或现在是第2页
      if (this.nowPageNum === 2 || !this.FlipModeConfig.autoDoublePageModeFlag) {
        this.flipPage(-1);
        return;
      }
      //如果前一页是双开叶
      let pervIsDouble = this.checkImageIsDoublePage_byPageNum(
        this.nowPageNum - 1
      );
      if (pervIsDouble) {
        this.flipPage(-1);
        return;
      }
      //如果前前页是双开叶
      let PervPervIsDouble = this.checkImageIsDoublePage_byPageNum(
        this.nowPageNum - 2
      );
      if (PervPervIsDouble) {
        this.flipPage(-1);
        return;
      }
      //都没return掉,那么前两张可以合并,减两页
      this.flipPage(-2);
    },

    //给一个页数,然后判断自动双页模式下,是否应该预读并合并显示下一页
    checkMergedStatus_ByPageNum(pageNum: number) {
      //如果没有开启自动双页模式,当然不需要
      if (!this.FlipModeConfig.autoDoublePageModeFlag) {
        return false;
      }
      //可能传入的错误值,打印到控制台
      if (pageNum <= 0 || pageNum >= this.book.page_count) {
        console.log("Error pageNum :" + pageNum);
        return false;
      }

      //已经是最后一页了,显然不需要自动合并下一页
      if (pageNum === this.book.page_count) {
        return false;
      }
      //分析现在这张图片的宽高比,看是不是双开页
      let now_page_is_double_page =
        this.checkImageIsDoublePage_byPageNum(pageNum);
      //分析下一张漫画的宽高比,看是不是双开页
      let next_page_is_double_page = this.checkImageIsDoublePage_byPageNum(
        pageNum + 1
      );
      //如果现在这张就是开页漫画,直接不用比
      //如果下一张漫画是开页,显然也没法合并
      return !(now_page_is_double_page || next_page_is_double_page);
    },
    checkImageIsDoublePage_byPageNum(pageNum: number) {
      //如果传进了错误值
      if (pageNum <= 0 || pageNum > this.book.page_count) {
        console.log("Error checkImageIsDoublePage_byPageNum:" + pageNum);
        return false;
      }
      // if (this.book.pages.images[pageNum - 1].image_type === "SinglePage") {
      //   return false;
      // }
      // if (this.book.pages.images[pageNum - 1].image_type === "DoublePage") {
      //   return true;
      // }
      let image = new Image();
      let temp_flag = false; //返回结果用
      image.src = this.book.pages.images[pageNum - 1].url;
      // image.complete 图片是否完全加载完成。
      //https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLImageElement/complete

      // https://corbusier.github.io/2017/06/29/%E5%9B%BE%E7%89%87%E7%9A%84%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E4%B8%8Eonload%E5%87%BD%E6%95%B0/
      // onload函数要写在改变src前,这样确保了onload函数一定会被调用
      // complete只是变向的在判断img是否已经触发了load事件,而且是不精准的判断
      // complete在不同浏览器下,表现不一致,不建议使用
      // 无论浏览器是否存在图片缓存,重新请求图片地址,都会触发onload事件

      // 牵扯到加载资源,这段代码需要改进……
      if (image.complete) {
        return image.width >= image.height;
      } else {
        //否则加载图片
        image.onload = function () {
          //是单页漫画
          if (image.width < image.height) {
            image.onload = null; // 避免重复加载
            temp_flag = false; //宽小于高,是是竖着的,单页漫画
          } else {
            //是双页漫画
            image.onload = null; // 避免重复加载
            temp_flag = true; //宽大于高,很可能是开页
          }
        };
        return temp_flag;
      }
    },

    //翻页,其实不限页数
    flipPage: function (num: number) {
      if (
        this.nowPageNum + num <= this.book.page_count &&
        this.nowPageNum + num >= 1
      ) {
        this.nowPageNum = this.nowPageNum + num;
      } else {
        // console.log("无法继续翻,Num:" + num)
        if (num > 0) {
          this.message.info(this.$t("hintLastPage"));
        } else {
          this.message.info(this.$t("hintFirstPage"));
        }
      }
      //保存页数
      this.saveLocalBookMark(this.nowPageNum);
    },
    //拖动进度条,或翻页的时候保存页数
    saveLocalBookMark(value: number, sendWSMessage = true) {
      if (this.FlipModeConfig.saveNowPageNumFlag) {
        localStorage.setItem("nowPageNum" + this.book.id, value.toString());
      }
      //发送翻页消息到服务器
      if (sendWSMessage && this.FlipModeConfig.syncPageByWS) {
        this.sendNowPage();
      }
    },
    //跳转到指定页数
    toPage: function (num: number, sendWSMessage = true) {
      if (num <= this.book.page_count && num >= 1) {
        this.nowPageNum = num;
      }
      //保存页数
      this.saveLocalBookMark(this.nowPageNum, sendWSMessage);
    },

    // 键盘事件
    handleKeyup(event: any) {
      //错误:(815, 49) 不允许从实参中引用 'caller' 和 'callee'
      const e = event || window.event;
      if (!e) return;
      //https://developer.mozilla.org/zh-CN/docs/Web/API/KeyboardEvent/keyCode
      switch (e.key) {
        case "ArrowUp":
        case "PageUp":
          this.flipPage(-1); //上一页
          break;
        case "ArrowLeft":
          this.FlipModeConfig.rightToLeftFlag
            ? this.toPerviousPage()
            : this.toNextPage();
          break;
        case "ArrowRight":
          this.FlipModeConfig.rightToLeftFlag
            ? this.toNextPage()
            : this.toPerviousPage();
          break;
        case "Space":
        case "ArrowDown":
        case "PageDown":
          this.flipPage(1); //下一页
          break;
        case "Home":
          this.toPage(1); //跳转到第一页
          break;
        case "End":
          this.toPage(this.book.page_count); //跳转到最后一页
          break;
        case "Ctrl":
          // Ctrl key pressed //组合键？
          //openOverlay();
          break;
      }
      // console.log(e.keyCode);
      // console.log(e.key);
    },

    setShowHeaderChange(value: boolean) {
      console.log("value:" + value);
      this.FlipModeConfig.showHeaderFlag_FlipMode = value;
      localStorage.setItem("showHeaderFlag_FlipMode", value ? "true" : "false");
      // console.log(
      //   "cookie设置完毕: showHeaderFlag_FlipMode=" +
      //   localStorage.getItem("showHeaderFlag_FlipMode")
      // );
    },
    setShowFooterFlagChange(value: boolean) {
      console.log("value:" + value);
      this.FlipModeConfig.showFooterFlag_FlipMode = value;
      localStorage.setItem("showFooterFlag_FlipMode", value ? "true" : "false");
      // console.log(
      //   "cookie设置完毕: showFooterFlag_FlipMode=" +
      //   localStorage.getItem("showFooterFlag_FlipMode")
      // );
    },

    setShowPageNumChange(value: boolean) {
      console.log("value:" + value);
      this.FlipModeConfig.showPageHintFlag_FlipMode = value;
      localStorage.setItem("showPageHintFlag_FlipMode", value ? "true" : "false");
    },

    setFlipScreenFlag(value: boolean) {
      console.log("value:" + value);
      this.FlipModeConfig.rightToLeftFlag = value;
      localStorage.setItem("rightToLeftFlag", value ? "true" : "false");
    },

    setHideToolbar(value: boolean) {
      console.log("value:" + value);
      this.hideToolbar = value;
      localStorage.setItem("HideToolbar", value ? "true" : "false");
    },

    setSyncPageByWS(value: boolean) {
      console.log("value:" + value);
      this.FlipModeConfig.syncPageByWS = value;
      localStorage.setItem("SyncPageFlag", value ? "true" : "false");
    },

    setSavePageNumFlag(value: boolean) {
      console.log("value:" + value);
      this.FlipModeConfig.saveNowPageNumFlag = value;
      localStorage.setItem("saveNowPageNumFlag", value ? "true" : "false");
    },

    setDebugModeFlag(value: boolean) {
      console.log("value:" + value);
      this.FlipModeConfig.debugModeFlag = value;
      //关闭Debug模式的时候顺便也关上“自动合并单双页”的功能（因为还有BUG）
      if (!value) {
        this.FlipModeConfig.autoDoublePageModeFlag = false;
      }
      localStorage.setItem("debugModeFlag", value ? "true" : "false");
      // console.log(
      //   "cookie设置完毕: debugModeFlag=" + localStorage.getItem("debugModeFlag")
      // );
    },

    setAutoDoublePage_FlipMode(value: boolean) {
      console.log("value:" + value);
      this.FlipModeConfig.autoDoublePageModeFlag = value;
      if (value) {
        this.FlipModeConfig.doublePageModeFlag = false;
      }
      localStorage.setItem("autoDoublePageModeFlag", value ? "true" : "false");
    },

    setSimpleDoublePage_FlipMode(value: boolean) {
      console.log("value:" + value);
      this.FlipModeConfig.doublePageModeFlag = value;
      if (value) {
        this.FlipModeConfig.autoDoublePageModeFlag = false;
      }
      localStorage.setItem("doublePageModeFlag", value ? "true" : "false");
    },
  },

  computed: {
    //页数或素描模式的提示
    pageNumOrSketchHint() {
      if (this.FlipModeConfig.sketchModeFlag) {
        let nowSecond = ((this.sketchSecondCount % this.sketchFlipSecond) + 1).toFixed();
        let donePage = (this.sketchSecondCount / this.sketchFlipSecond).toFixed();
        let totalMinutes = (this.sketchSecondCount + 1) / 60;
        //计算几小时几分
        let MinutesAndHourString = "";
        //如果不满意1小时,就不显示小时
        if (this.sketchSecondCount < 3600) {
          MinutesAndHourString = totalMinutes.toFixed() + this.$t("minute");
        } else {
          MinutesAndHourString =
            (totalMinutes / 60).toFixed().toString() +
            this.$t("hour") +
            (totalMinutes % 60).toFixed().toString() +
            this.$t("minute");
        }
        let AllTimeString =
          MinutesAndHourString +
          ((this.sketchSecondCount + 1) % 60).toFixed() +
          this.$t("second");
        return (
          this.$t("now_is") +
          nowSecond +
          this.$t("second") +
          "  " +
          this.$t("totalTime") +
          AllTimeString +
          "   " +
          this.$t("interval") +
          this.sketchFlipSecond +
          this.$t("second") +
          "  " +
          this.$t("total_is") +
          donePage +
          this.$t("page")
        );
      } else {
        return this.nowPageNum + "/" + this.book.page_count;
      }
    },
    mangaAreaHeight() {
      let Height = 95;
      //页头和底部拖动条都显示,或有一个显示的时候,95%
      if (this.FlipModeConfig.showFooterFlag_FlipMode && this.FlipModeConfig.showHeaderFlag_FlipMode) {
        Height = 95;
      }
      if (this.FlipModeConfig.showFooterFlag_FlipMode && !this.FlipModeConfig.showHeaderFlag_FlipMode) {
        Height = 95;
      }
      if (!this.FlipModeConfig.showFooterFlag_FlipMode && this.FlipModeConfig.showHeaderFlag_FlipMode) {
        Height = 95;
      }
      //页头和底部拖动条都不显示的时候,漫画占满屏幕
      if (!this.FlipModeConfig.showFooterFlag_FlipMode && !this.FlipModeConfig.showHeaderFlag_FlipMode) {
        Height = 100;
      }
      return Height + "vh";
    },
    mangaImageHeight() {
      let Height = 95;
      //页头和底部拖动条都显示,或有一个显示的时候,95%
      if (this.FlipModeConfig.showFooterFlag_FlipMode && this.FlipModeConfig.showHeaderFlag_FlipMode) {
        Height = 95;
      }
      if (this.FlipModeConfig.showFooterFlag_FlipMode && !this.FlipModeConfig.showHeaderFlag_FlipMode) {
        Height = 95;
      }
      if (!this.FlipModeConfig.showFooterFlag_FlipMode && this.FlipModeConfig.showHeaderFlag_FlipMode) {
        Height = 95;
      }
      //页头和拖动条都不显示的时候,漫画占满屏幕
      if (!this.FlipModeConfig.showFooterFlag_FlipMode && !this.FlipModeConfig.showHeaderFlag_FlipMode) {
        Height = 100;
      }
      //与上面唯一的不同,减去素描提示的空间
      if (this.FlipModeConfig.showPageHintFlag_FlipMode) {
        if (this.FlipModeConfig.readerMode === "sketch") {
          Height = Height - 6;
        } else {
          Height = Height - 3;
        }
      }
      return Height + "vh";
    },
    //进入素描模式的时候,把高度放大一倍
    sketchHintHeight() {
      if (this.FlipModeConfig.readerMode === "sketch") {
        return "6vh";
      } else {
        return "3vh";
      }
    },
    //进入素描模式的时候,把字体放大
    sketchHintFontSize() {
      if (this.FlipModeConfig.readerMode === "sketch") {
        return "24px";
      } else {
        return "16px";
      }
    },
    //从左到右还是从右到左
    get_flex_direction() {
      if (this.FlipModeConfig.rightToLeftFlag) {
        return "row";
      } else {
        return "row-reverse";
      }
    },
  },
});
</script>

<style scoped>
/* 题头的显隐效果 */
/* https://v3.cn.vuejs.org/guide/transitions-enterleave.html#%E5%8D%95%E5%85%83%E7%B4%A0-%E7%BB%84%E4%BB%B6%E7%9A%84%E8%BF%87%E6%B8%A1= */
/* 可以为进入和离开动画设置不同的持续时间和动画函数 */
/* v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 */
.header-bottom-enter-active {
  transition: all 0.3s ease;
}

/* v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 */
/* cubic-bezier() 函数定义了一个贝塞尔曲线(Cubic Bezier) */
.header-bottom-leave-active {
  transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);
}

/* v-enter-from：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 */
/* v-leave-to：离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave-from 被移除)，在过渡/动画完成之后移除。 */
.header-bottom-enter-from,
.header-bottom-leave-to {
  /* transform: translateY(-20px); */
  opacity: 0;
}

/* 参考CSS盒子模型 */
/* https://www.runoob.com/css/css-boxmodel.html */
/* CSS 高度和宽度 */
/* https://www.w3school.com.cn/css/css_dimension.asp */
/* CSS Flexbox 布局 */
/* https://www.w3school.com.cn/css/css3_flexbox.asp */

* {
  box-sizing: border-box;
}

.main {
  font-family: Arial;
  margin: 0;
  padding: 0;
  /* height: v-bind(mangaAreaHeight); */
  display: flex;
  max-width: 100%;
  /* flex-direction: column垂直堆叠 flex 项目（从上到下）,column-reverse从下到上 row从左到右 row-reverse从右到左 */
  flex-direction: column;
  /* justify-content 属性用于对齐 flex 项目。 将 justify-content 和 align-items 属性设置为居中,flex 项目将完美居中： */
  justify-content: center;
  /* center 值将 flex 项目在容器中间对齐： */
  align-items: center;
  background: v-bind("model.backgroundColor");
}

/* 漫画div */
.manga_area {
  width: 100vw;
  max-height: 100vh;
  height: 100vh;
  max-width: 100vw;
  padding: 0;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: baseline;
  /* 不可以被选中 */
  user-select: none;
  /* 火狐 */
  -moz-user-select: none;
  /* 谷歌 */
  -webkit-user-select: none;
  /* border-radius: 3px; */
  /* box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19); */
}

/* 漫画div中的图片div*/
.manga_area_img_div {
  width: 100vw;
  /* height: v-bind(mangaAreaHeight); */
  height: 100vh;
  display: flex;
  flex-direction: v-bind(get_flex_direction);
  justify-content: center;
  align-items: center;
  margin: 0px;
}

/* 最后的一或两张图片*/
.manga_area_img_div img {
  max-height: 100vh;
  max-width: 100vw;
  min-width: 0;
  width: auto;
  display: block;
  user-select: none;
  /* 下面两句，是设定高度为100%，同时保持比例缩放的关键（类似sketch small pages） */
  min-height: 100vh;
  object-fit: contain;
  /* 两张图片之间不要留空间*/
  padding: 0px;
  /* background-color: #aaa; */
}
</style>
